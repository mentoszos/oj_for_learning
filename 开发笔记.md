- jvm、jdbc、数据库之间，要统一时区，如果有一个是utc一个是东八区，则jdbc会根据时区自动修改时间，会出现我在10点提交的信息在数据库里不是10点的现象。
- mybatis-plus中，对于批量操作（新增和删除），如果不在url显式把rewriteBatchedStatements=true写上，则批量操作实际上是一条条insert或delete语句在运行；加上后则类似于insert ... values(),()...
- 一个参考的url写法，应指定字符集、时区、开启batch等。url: jdbc:mysql://localhost:3306/codecollab_oj?useUnicode=true&characterEncoding=utf-8&useSSL=false&serverTimezone=Asia/Shanghai&rewriteBatchedStatements=true

- lambda表达式内部引用的外部变量应该是final的，煞笔。

- BeanUtil.copyProperties（无论hutool或spring的）只关注属性名是否相同，spring的无法进行类型转换，hutool能把integer和long这种转换，本质上是通过反射去匹配名称，较慢。有更快的写法。





修改测试用例流程：：

- 首先分页展示测试用例，其中信息包括id，questionid，active，sortnum，timelimit，memorylimit。
- 在当前页面可以修改active状态（或者可以挪到下一个阶段）
- 点进去可以修改timelimit，memorylimit。提供两个按钮可以获取测试用例的输入和输出
- 再点进去获取测试用例的输入或者输出

沙箱方案：

- ProcessBuilder，类似用java代码调用命令行，让进来的java文件经过编译、运行得到结果。这种方式运行的代码相当于沙箱主线程的一个子线程，他和沙箱共享一个资源，他可以从代码层面上扫描、删除服务器上的内容，也可以写代码崩掉我的沙箱服务（比如通过JNI调用底层方法，可以无视jvm的内存设置）。总的来说就是资源控制比较困难。
- 基于docker的java-api调用，让代码调用docker，能起到资源隔绝的作用，那为什么第一种不行？docker还有啥优势？
- 第三方沙箱api，成熟可用，但体现不出我的工作量。

最终采用基于docker的方案，[api文档](https://github.com/docker-java/docker-java/blob/main/docs/getting_started.md)



